<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>O Pergaminho Arcano</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

  <style>
    :root { --cor-arcana:#b24cff; }

    html, body {
      margin:0; padding:0; width:100%; height:100%;
      background:#000; color:#fff; font-family:'MedievalSharp', cursive;
      overflow:hidden;
    }

    /* Selo central */
    #seal-container{
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      width:160px; height:160px; display:flex; justify-content:center; align-items:center;
      cursor:pointer; z-index:20; pointer-events:auto;
    }
    #arcane-seal-img{
      width:120px; height:auto; pointer-events:auto;
      filter:drop-shadow(0 0 22px var(--cor-arcana));
      transition:opacity .4s ease-out, filter .4s ease-out;
    }
    #arcane-seal-img.clicked{ opacity:0; filter:drop-shadow(0 0 5px var(--cor-arcana)); }

    /* Canvas Three.js */
    #three-canvas{ position:fixed; top:0; left:0; z-index:1; }

    /* Intersticial */
    #interstitial{
      display:none; opacity:0;
      position:fixed; inset:0; z-index:9;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
      background:transparent;
      transition:opacity .5s ease;
    }
    #interstitial.show{ opacity:1; }
    #interstitial.hide{ opacity:0; }

    .interstitial-text{
      max-width: 800px; padding:0 24px; text-align:center;
      font-size: clamp(20px, 4vw, 36px);
      color:#fff;
      text-shadow: 0 0 10px var(--cor-arcana), 0 0 20px var(--cor-arcana);
      animation: distortPulse 1.2s infinite;
      filter: brightness(1.05);
    }
    @keyframes distortPulse{
      0%   { transform: skew(0deg,0deg); filter: blur(0px); }
      25%  { transform: skew(0.3deg,-0.4deg); filter: blur(0.4px); text-shadow:0 0 6px #fff,0 0 14px var(--cor-arcana),0 0 24px var(--cor-arcana); }
      50%  { transform: skew(-0.4deg,0.2deg); filter: blur(0.6px); text-shadow:0 0 10px #fff,0 0 20px var(--cor-arcana),0 0 30px var(--cor-arcana); }
      75%  { transform: skew(0.2deg,-0.2deg); filter: blur(0.3px); text-shadow:0 0 6px #fff,0 0 14px var(--cor-arcana),0 0 24px var(--cor-arcana); }
      100% { transform: skew(0deg,0deg); filter: blur(0px); }
    }

    /* Glitch G1 */
    .glitch-lines{
      position:absolute; inset:0; display:none; z-index:10; pointer-events:none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.12) 0px,
        rgba(255,255,255,0.12) 2px,
        rgba(178,76,255,0.35) 3px,
        rgba(178,76,255,0.0) 6px
      );
      mix-blend-mode: screen;
      filter: blur(0.3px);
    }
    .glitch-run{ display:block; animation: glitchLines 0.45s steps(8,end) forwards; }
    @keyframes glitchLines{
      0%   { transform: translateY(0px); opacity:0.85; }
      20%  { transform: translateY(-6px); opacity:0.9; }
      40%  { transform: translateY(8px); opacity:0.75; }
      60%  { transform: translateY(-10px); opacity:0.9; }
      80%  { transform: translateY(12px); opacity:0.7; }
      100% { transform: translateY(0px); opacity:0; }
    }

    /* Blackout da assinatura */
    #blackout{
      display:none; opacity:0;
      position:fixed; inset:0; background:#000;
      z-index:9; transition: opacity .5s ease;
    }
    #blackout.show{ display:block; opacity:1; }

    /* Assinatura final */
    #signature-container{
      display:none; opacity:0; position:fixed; bottom:110px; left:50%;
      transform:translateX(-50%); z-index:10; text-align:center; font-size:1.2rem;
      font-family:'MedievalSharp', cursive; transition:opacity 1s ease-in;
      max-width:600px; line-height:1.35;
    }
    /* Glow pulsando suave */
    #signature{
      color:#fff;
      text-shadow:
        0 0 10px #ffffff,
        0 0 20px var(--cor-arcana),
        0 0 32px var(--cor-arcana);
      animation: signatureSoftPulse 2.2s ease-in-out infinite;
    }
    @keyframes signatureSoftPulse{
      0%,100%{
        text-shadow:
          0 0 8px #ffffff,
          0 0 16px var(--cor-arcana),
          0 0 26px var(--cor-arcana);
      }
      50%{
        text-shadow:
          0 0 14px #ffffff,
          0 0 28px var(--cor-arcana),
          0 0 44px var(--cor-arcana);
      }
    }
  </style>
</head>
<body>

  <div id="seal-container">
    <img id="arcane-seal-img" src="./assets/selo-arcano.png" alt="Selo Arcano">
  </div>

  <canvas id="three-canvas"></canvas>

  <!-- Intersticial -->
  <div id="interstitial">
    <div class="interstitial-text">Sua mente é preenchida por um fluxo de pensamentos</div>
    <div class="glitch-lines" id="glitchLines"></div>
  </div>

  <!-- Blackout para assinatura -->
  <div id="blackout"></div>

  <div id="signature-container">
    <p id="signature">
O coração dispara antes que você perceba que deixou a carta cair. O papel atinge o chão, mas a sensação de contato não some com ele. Algo fica preso na sua cabeça, como se um pensamento entrasse sem pedir permissão. Não é visão, nem sonho. É lembrança de algo que você nunca viveu.<br><br>
A imagem vem inteira, sem construção, sem origem: uma taverna que você nunca viu, mas reconhece. Tábuas escuras, cheiro de ferrugem, luz baixa demais para ser aconchegante, mesas que já desistiram de permanecer retas. Ferrugem & Ossos. Velha Chama. O nome surge pronto, como se sempre estivesse guardado em algum ponto da sua mente que não era seu.<br><br>
Ninguém diz que você deve ir.<br>
Mas a sensação é de que você já está atrasado.
    </p>
  </div>

  <!-- Shaders -->
  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  </script>

  <!-- Fragment com batimento sincronizado (via BEAT_MAP + rate) -->
  <script type="x-shader/x-fragment" id="fragmentShader">
    uniform sampler2D map;
    uniform float time;
    uniform vec3 glowColor;
    uniform vec3 deepColor;
    uniform float distortionStrength; // JS: DIST_BASE..DIST_PEAK
    uniform float beatLevel;          // JS: pulso 0..1 (já reduzido)

    varying vec2 vUv;
    void main(){
      vec2 uv = vUv;

      /* Perspectiva leve (evita borrão do warp quadrático) */
      vec2 p = uv * 2.0 - 1.0;
      float depth = 1.0 + (p.y * 0.18);
      p /= depth;
      vec2 warpedUv = p * 0.5 + 0.5;

      /* Distorção senoidal controlada por 'distortionStrength' */
      vec2 distortedUv = warpedUv;
      float d = distortionStrength; /* ~0.0008 → ~0.0036 */
      distortedUv.x += sin(warpedUv.y * 18.0 + time * 4.2) * d;
      distortedUv.y += cos(warpedUv.x * 16.0 + time * 4.8) * d;

      vec4 texel = texture2D(map, clamp(distortedUv, 0.0, 1.0));

      /* Pulso de cor/brilho (branco ↔ roxo) — já com intensidade reduzida */
      float b = clamp(beatLevel, 0.0, 1.0);
      vec3 mixColor = mix(vec3(1.0), deepColor, b);
      vec3 finalColor = mix(vec3(1.0), mixColor, texel.a);
      finalColor += deepColor * texel.a * (0.06 + 0.10*b);

      gl_FragColor = vec4(finalColor, texel.a);
    }
  </script>

  <script>
    /* ============ TEXTO (1 linha vazia entre blocos) ============ */
    const LOREM_IPSUM_ARCANO = `
Nas entranhas do real, onde a forma range,
eles caminham sem saber que já foram colhidos.
O mundo fede antes de morrer,
mas vós chamais isso de ordem.

Sob a pedra há dente,
sob o dente há fome,
sob a fome há ritmo,
e o ritmo vos aguarda.

Eles respiram, mas o ar não os quer.
A carne permanece, mas a lembrança apodrece.
O tempo só mastiga o que ainda resiste,
e nada resiste por muito.

O eixo tritura o que ousa lembrar.
A cidade dorme sobre ossos que não consentem.
Chama-se paz ao que sangra devagar,
chama-se vida ao que ainda não cedeu.

Vós sois as falhas do esquecimento,
os nomes que o silêncio não digeriu.
A Fenda não oferece escolha —
apenas retorno.

A vinda já começou
antes do passo.
A queda já vos guarda
antes da borda.

Ouçam.
Desçam.
Cedam.
Retornem.

A pele racha.
O selo abre.
A ruína respira.
E vos chama.
    `;

    /* ============ VARIÁVEIS ============ */
    let scene, camera, renderer;
    let sfx1, sfx2, sfx25, sfx3;
    let sfx2Id = null, sfx25Id = null;
    let sfx2PreId = null, sfx25PreId = null, sfx3PreId = null;
    let binauralTargets = [];
    let crawlGroup, textMesh, textHeight;
    let animationInProgress = false;
    let endThreshold = 0;
    let clock = new THREE.Clock();

    const ARCANE_PURPLE = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--cor-arcana').trim());
    const DEEP_COLOR = new THREE.Color(0x3C0061);

    /* ============ CONTROLES VISUAIS (como no modular) ============ */
    const CRAWL_BASE = 0.32;       // início suave
    const CRAWL_MAX  = 0.78;       // fim mais rápido
    const DIST_BASE  = 0.0008;     // distorção quase imperceptível no começo
    const DIST_PEAK  = 0.0036;     // moderada no final

    /* ============ MAPA DE BATIDAS (pré-mapeado, escalável por rate) ============ */
    const BEAT_MAP = (() => {
      const beats = [];
      const start = 0.45;
      const interval = 0.78;
      const total = 240;
      for (let i=0;i<total;i++) beats.push(start + i*interval);
      return beats;
    })();

    let beatIndex = 0;
    let lastPulseAt = 0;
    let beatLevelVisual = 0; // 0..1 (decai após cada thump)

    /* ============ INIT ============ */
    function init(){
      Howler.autoSuspend = false;
      Howler.mute(false);
      Howler.volume(1.0);

      setupAudio();
      setupScene();
      setupListeners();
      startBinauralLoop();
    }

    /* ============ AUDIO ============ */
    function setupAudio(){
      sfx1  = new Howl({ src:['./assets/sfx1.mp3'],   volume:0.8, loop:false, html5:false });
      sfx2  = new Howl({ src:['./assets/sfx2.mp3'],   volume:0.6, loop:true,  html5:false });
      sfx25 = new Howl({ src:['./assets/sfx2_5.mp3'], volume:1.0, loop:true,  html5:false });
      sfx3  = new Howl({ src:['./assets/sfx3.mp3'],   volume:0.6, loop:false, html5:false });

      [sfx1, sfx2, sfx25, sfx3].forEach(h=>{
        h.once('playerror', (id)=>{ try{ Howler.ctx.resume(); }catch(e){} try{ h.play(id); }catch(e){} });
      });
    }

    /* ============ SCENE ============ */
    function setupScene(){
      const canvas = document.getElementById('three-canvas');
      scene = new THREE.Scene();

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 1, 10000);
      camera.position.set(0, 130, 480);
      camera.lookAt(0, 0, 0);
      scene.add(camera);

      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.5)); // nitidez sem blur
    }

    function setupListeners(){
      document.getElementById('seal-container').addEventListener('click', startExperience, { once:true });
      window.addEventListener('resize', onWindowResize, { passive:true });
      window.addEventListener('orientationchange', onWindowResize, { passive:true });
      document.addEventListener('visibilitychange', ()=>{ if (Howler.ctx && Howler.ctx.state!=='running') Howler.ctx.resume(); });
    }

    /* ============ FLUXO PRINCIPAL ============ */
    function startExperience(){
      if (animationInProgress) return;
      animationInProgress = true;

      try{ if (Howler.ctx && Howler.ctx.state !== 'running') Howler.ctx.resume(); }catch(e){}

      const sealImg = document.getElementById('arcane-seal-img');
      sealImg.classList.add('clicked');

      // sfx1
      const id1 = sfx1.play();
      makeBinaural(sfx1, id1, {speed:1.4, radius:0.9, jitter:0.35});

      // Pré-desbloqueio iOS — todos
      sfx2PreId = sfx2.play();   sfx2.volume(0, sfx2PreId);   sfx2.pause(sfx2PreId);
      sfx25PreId = sfx25.play(); sfx25.volume(0, sfx25PreId); sfx25.pause(sfx25PreId);
      sfx3PreId = sfx3.play();   sfx3.volume(0, sfx3PreId);   sfx3.pause(sfx3PreId);

      setTimeout(() => { document.getElementById('seal-container').style.display='none'; }, 400);

      // Intersticial + glitch; ao terminar, inicia áudio+texto
      showInterstitialAndThen(3000, () => {
        startTextAndAudio();
      });
    }

    function showInterstitialAndThen(ms, cb){
      const inter = document.getElementById('interstitial');
      const glitch = document.getElementById('glitchLines');

      inter.style.display = 'flex';
      requestAnimationFrame(() => inter.classList.add('show'));

      setTimeout(() => {
        glitch.classList.add('glitch-run'); // ~450ms
        setTimeout(() => {
          inter.classList.remove('show');
          inter.style.display = 'none';
          glitch.classList.remove('glitch-run');
          cb && cb();
        }, 450);
      }, ms);
    }

    function startTextAndAudio(){
      // sfx2: fade-in 3s
      if (!sfx2PreId) sfx2PreId = sfx2.play();
      sfx2.seek(0, sfx2PreId);
      sfx2.play(sfx2PreId);
      sfx2.fade(0, 0.6, 3000, sfx2PreId);
      sfx2Id = sfx2PreId;
      makeBinaural(sfx2, sfx2Id, {speed:1.3, radius:1.2, jitter:0.5});
      setTimeout(() => { applyReverbToSound(sfx2, sfx2Id, {seconds:1.8, decay:3.0, wet:0.8}); }, 120);

      // sfx2_5: batimento + fade-in 3s
      if (!sfx25PreId) sfx25PreId = sfx25.play();
      sfx25.seek(0, sfx25PreId);
      sfx25.play(sfx25PreId);
      sfx25.fade(0, 1.0, 3000, sfx25PreId);
      sfx25Id = sfx25PreId;
      makeBinaural(sfx25, sfx25Id, {speed:1.5, radius:1.0, jitter:0.45});

      // Reset do estado do mapa de batidas
      beatIndex = 0; lastPulseAt = performance.now()/1000; beatLevelVisual = 0;

      // Texto sobe
      createCrawlText();
      animate();
    }

    /* ============ TEXTO EM CANVAS (DPR SAFE) ============ */
    function createCrawlText(){
      const textCanvasObj = createTextCanvas(LOREM_IPSUM_ARCANO);
      const textCanvas = textCanvasObj.canvas;
      textHeight = textCanvasObj.cssHeight;

      const texture = new THREE.CanvasTexture(textCanvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      const material = new THREE.ShaderMaterial({
        uniforms:{
          map:{ value:texture },
          time:{ value:0.0 },
          glowColor:{ value: ARCANE_PURPLE },
          deepColor:{ value: DEEP_COLOR },
          distortionStrength:{ value:DIST_BASE },
          beatLevel:{ value:0.0 }
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent:true, side:THREE.DoubleSide
      });

      const geometry = new THREE.PlaneGeometry(textCanvasObj.cssWidth, textCanvasObj.cssHeight);
      textMesh = new THREE.Mesh(geometry, material);

      crawlGroup = new THREE.Group();
      crawlGroup.add(textMesh);

      crawlGroup.rotation.x = 0;
      const startY = -textCanvasObj.cssHeight / 2 - 240;
      crawlGroup.position.y = startY;

      /* Aumentado para garantir que o texto role inteiro antes da assinatura */
      endThreshold = (textCanvasObj.cssHeight * Math.cos(crawlGroup.rotation.x)) * 1.20;

      scene.add(crawlGroup);
    }

    function createTextCanvas(text){
      const lines = text.split('\n');

      const isMobile = window.innerWidth <= 480;
      let fontSize = isMobile ? 28 : 32;
      let lineHeight = fontSize * 1.28;

      const cssWidth = 1024;
      const cssHeight = (lines.length * lineHeight + (fontSize * 2)) | 0;

      const dpr = Math.min(window.devicePixelRatio || 1, 2.5);
      const canvas = document.createElement('canvas');
      canvas.width  = Math.floor(cssWidth  * dpr);
      canvas.height = Math.floor(cssHeight * dpr);

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.font = `700 ${fontSize}px 'Cinzel Decorative'`; /* negrito */
      ctx.fillStyle = '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'alphabetic';

      let y = fontSize * 2;
      for (const line of lines){
        ctx.fillText(line, cssWidth/2, y);
        y += lineHeight;
      }

      return { canvas, cssWidth, cssHeight };
    }

    /* ============ BATIMENTO (mapa + detecção por seek) ============ */
    function maybeTriggerBeatPulse(){
      if (sfx25Id === null || !sfx25.playing(sfx25Id)) return;
      const pos = sfx25.seek(sfx25Id) || 0;

      let rateNow = 1.0;
      try { rateNow = sfx25._rate || 1.0; } catch(e){ rateNow = 1.0; }
      if (!rateNow || rateNow <= 0) rateNow = 1.0;

      while (beatIndex < BEAT_MAP.length) {
        const scheduled = BEAT_MAP[beatIndex] / rateNow;
        if (pos + 0.01 >= scheduled) {
          lastPulseAt = performance.now()/1000;
          beatLevelVisual = 1.0;
          beatIndex++;
        } else {
          break;
        }
      }
    }

    function getBeatLevelDecayed(){
      const now = performance.now()/1000;
      const dt = Math.max(0, now - lastPulseAt);
      const decay = Math.exp(-dt / 0.18);
      return Math.min(1, Math.max(0, beatLevelVisual * decay));
    }

    /* ============ ANIMAÇÃO & LOOP ============ */
    function animate(){
      requestAnimationFrame(animate);
      if (!animationInProgress) return;

      const t = clock.getElapsedTime();

      if (textMesh && textMesh.material && textMesh.material.uniforms.time){
        textMesh.material.uniforms.time.value = t;
      }

      if (crawlGroup){
        const startY = -textHeight / 2 - 240;
        const totalScroll = endThreshold - startY;
        const currentScroll = crawlGroup.position.y - startY;
        const progress = Math.min(1, Math.max(0, currentScroll / totalScroll));

        const speed = CRAWL_BASE + (CRAWL_MAX - CRAWL_BASE) * Math.pow(progress, 1.35);
        crawlGroup.position.y += speed;

        let rate = 1.0;
        if      (progress > 0.40) rate = 1.10;
        if      (progress > 0.60) rate = 1.20;
        if      (progress > 0.80) rate = 1.30;
        if      (progress > 0.92) rate = 1.38;
        if      (progress > 0.98) rate = 1.45;
        if (sfx25Id !== null && sfx25.playing(sfx25Id)) sfx25.rate(rate, sfx25Id);

        /* Pulso real (batida detectada) */
        maybeTriggerBeatPulse();
        const pulse = getBeatLevelDecayed();

        /* Intensidade reduzida para ~15% do anterior */
        const kReduced = 0.15 * (0.65*pulse + 0.35*Math.pow(progress,1.2));
        const dist = DIST_BASE + (DIST_PEAK - DIST_BASE) * kReduced;

        try{
          if (textMesh.material && textMesh.material.uniforms){
            const u = textMesh.material.uniforms;
            if (u.distortionStrength) u.distortionStrength.value = dist;
            if (u.beatLevel)          u.beatLevel.value          = kReduced; // cor/brilho também reduzidos
          }
        }catch(e){}
      }

      /* Empurra um pouco além do limiar para garantir texto 100% exibido */
      if (crawlGroup && crawlGroup.position.y > (endThreshold + 24)){
        finishAnimation();
      }

      renderer.render(scene, camera);
    }

    function finishAnimation(){
      animationInProgress = false;

      if (crawlGroup){
        scene.remove(crawlGroup);
        if (textMesh.geometry) textMesh.geometry.dispose();
        if (textMesh.material){
          if (textMesh.material.map) textMesh.material.map.dispose();
          textMesh.material.dispose();
        }
      }

      /* Blackout antes da assinatura */
      const blackout = document.getElementById('blackout');
      blackout.classList.add('show');

      /* fade-out do ambiente e do batimento */
      if (sfx2Id !== null && sfx2.playing(sfx2Id)){
        sfx2.fade(sfx2.volume(sfx2Id), 0, 800, sfx2Id);
        setTimeout(() => { try{ sfx2.stop(sfx2Id); }catch(e){} }, 820);
      }
      if (sfx25Id !== null && sfx25.playing(sfx25Id)){
        sfx25.fade(sfx25.volume(sfx25Id), 0, 800, sfx25Id);
        setTimeout(() => { try{ sfx25.stop(sfx25Id); }catch(e){} }, 820);
      }

      /* Assinatura + sfx3 */
      const signature = document.getElementById('signature-container');
      signature.style.display = 'block';
      setTimeout(() => { signature.style.opacity = '1'; }, 50);

      setTimeout(() => {
        try{ if (Howler.ctx && Howler.ctx.state !== 'running') Howler.ctx.resume(); }catch(e){}
        sfx3.seek(0, sfx3PreId);
        sfx3.play(sfx3PreId);
        makeBinaural(sfx3, sfx3PreId, {speed:1.6, radius:0.8, jitter:0.4});
      }, 800);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* ============ AUDIO FX AUX ============ */
    function makeBinaural(howl, soundId, opts={}){
      const speed  = opts.speed  ?? 1.4;
      const radius = opts.radius ?? 1.0;
      const jitter = opts.jitter ?? 0.3;
      howl.pannerAttr({ panningModel:'HRTF', refDistance:1, rolloffFactor:0.9 }, soundId);
      howl.pos(0, 0, -0.3, soundId);
      binauralTargets.push({ howl, soundId, speed, radius, jitter, t0: performance.now()/1000 });
    }

    function startBinauralLoop(){
      function frame(){
        const now = performance.now()/1000;
        binauralTargets = binauralTargets.filter(target=>{
          const { howl, soundId, speed, radius, jitter, t0 } = target;
          if (!howl.playing(soundId)) return false;

          const t = (now - t0) * (1.0 / Math.max(0.001, speed));
          const a=2.3, b=1.7;
          const x = Math.sin(a*t) * radius * (0.85 + 0.15*Math.sin(t*3.1));
          const y = (Math.sin(b*t*0.7)*0.25) + (Math.random()-0.5)*0.02*jitter;
          const z = (Math.cos(a*t*0.9)*0.7) - 0.3 + (Math.random()- 0.5)*0.02*jitter;

          howl.pos(x,y,z, soundId);
          return true;
        });
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    function applyReverbToSound(howl, soundId, {seconds=1.8, decay=3.0, wet=0.8}={}){
      try{
        const ctx = Howler.ctx;
        const sound = howl._soundById(soundId);
        if (!sound) return;

        const sourceNode = sound._panner || sound._node;
        if (!sourceNode) return;

        if (sound.__reverbApplied) return;
        sound.__reverbApplied = true;

        const convolver = ctx.createConvolver();
        convolver.buffer = createImpulseResponse(ctx, seconds, decay);

        const wetGain = ctx.createGain(); wetGain.gain.value = wet;
        const dryGain = ctx.createGain(); dryGain.gain.value = 1 - wet;

        try{ sourceNode.disconnect(); }catch(e){}

        sourceNode.connect(dryGain);
        sourceNode.connect(convolver);

        convolver.connect(wetGain);
        dryGain.connect(Howler.masterGain);
        wetGain.connect(Howler.masterGain);

        sound.__reverb = { convolver, wetGain, dryGain };
      }catch(e){
        console.warn('Reverb não pôde ser aplicado:', e);
      }
    }

    function createImpulseResponse(ctx, seconds=1.8, decay=3.0){
      const rate = ctx.sampleRate;
      const length = Math.max(1, Math.floor(rate * seconds));
      const impulse = ctx.createBuffer(2, length, rate);
      for (let ch=0; ch<2; ch++){
        const data = impulse.getChannelData(ch);
        for (let i=0; i<length; i++){
          const n = Math.random()*2 - 1;
          data[i] = n * Math.pow(1 - i/length, decay);
        }
      }
      return impulse;
    }

    init();
  </script>
</body>
</html>
