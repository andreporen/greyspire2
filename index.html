<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Pergaminho Arcano</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <style>
        :root {
            --cor-arcana: #b24cff; /* Roxo arcano definido */
        }

        /* --- ESTILOS GERAIS --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            color: #ffffff;
            font-family: 'MedievalSharp', cursive;
            overflow: hidden;
        }

        /* --- SELO ARCANO (GATILHO) --- */
        #seal-container {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            cursor: pointer;
        }
        
        #arcane-seal-img {
            width: 100px;
            height: auto;
            filter: drop-shadow(0 0 20px var(--cor-arcana));
            transition: opacity 1.5s ease-out, filter 1.5s ease-out;
        }

        #arcane-seal-img.clicked {
            opacity: 0.6;
            filter: drop-shadow(0 0 8px var(--cor-arcana));
        }

        /* --- CENA 3D (THREE.JS) --- */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* --- ASSINATURA FINAL --- */
        #signature-container {
            display: none;
            opacity: 0;
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'MedievalSharp', cursive;
            transition: opacity 1s ease-in;
        }

        #signature {
            color: #000000; /* Letras pretas */
            animation: pulse-arcano 1s ease-in-out infinite;
        }

        /* ANIMAÇÃO REFORÇADA: Pulso de "consumido pela Fenda" */
        @keyframes pulse-arcano {
            0%, 100% {
                text-shadow:
                    0 0 15px #fff,
                    0 0 30px var(--cor-arcana),
                    0 0 50px var(--cor-arcana);
            }
            50% {
                text-shadow:
                    0 0 20px #fff,
                    0 0 40px var(--cor-arcana),
                    0 0 70px var(--cor-arcana),
                    0 0 100px var(--cor-arcana);
            }
        }
    </style>
</head>
<body>

    <div id="seal-container">
        <img id="arcane-seal-img" src="./selo-arcano.png" alt="Selo Arcano">
    </div>

    <canvas id="three-canvas"></canvas>

    <div id="signature-container">
        <p id="signature">Arcanista-mor Amaris Solun</p>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv;
        void main() {
            vUv = uv; // NECESSÁRIO para passar a UV para o fragment shader
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D map;
        uniform float time;
        uniform vec3 glowColor;
        uniform float distortionStrength;

        varying vec2 vUv;

        // Função de ruído (para a corrupção)
        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec2 distortedUv = vUv;
            
            // Aumenta a distorção para ser visível
            float noise = (rand(vUv * 10.0 + time * 0.5) - 0.5) * distortionStrength;
            distortedUv.x += sin(vUv.y * 15.0 + time * 8.0) * noise;
            distortedUv.y += cos(vUv.x * 15.0 + time * 7.0) * noise;

            vec4 texel = texture2D(map, distortedUv);
            
            // NOVO: Define um fator de brilho/pulsação baseado no tempo
            float pulseFactor = (sin(time * 3.0) * 0.5 + 0.5); // Pulsa entre 0.5 e 1.0

            // Base do brilho roxo: o roxo deve aparecer nas áreas do texto (onde texel.a > 0)
            vec3 purpleGlow = glowColor * texel.a * pulseFactor * 2.0; // Multiplicador para intensidade

            // Cor base do texto: mantém um pouco de branco, mas o roxo domina
            vec3 finalColor = mix(vec3(1.0, 1.0, 1.0), purpleGlow, texel.a); // Mistura branco e roxo

            // Adiciona um "halo" roxo mais forte
            finalColor += glowColor * texel.a * pulseFactor * 1.5;


            gl_FragColor = vec4(finalColor, texel.a);
        }
    </script>

    <script>
        // --- TEXTO LONGO (Estilo Pergaminho) ---
        const LOREM_IPSUM_ARCANO = `
Nas veias do cosmo, onde a luz teme pisar,
o Vazio pulsa em compasso ancestral.
Ouve, neófito, o sussurro das eras:
as engrenagens do destino rangem.

A Sétima Estrela sangrou sobre o véu,
tecendo a runa da Despossessão.
E do pó de estrelas mortas,
o Primeiro Selo foi forjado.

Não busque o poder que corrompe,
mas o saber que liberta.
Pois no coração do silêncio,
a verdade aguarda, paciente.

A geometria do efêmero,
a matemática da alma.
Tudo se dobra à Vontade
quando a Vontade é una com o Todo.

O Tempo é um rio que flui para trás,
e a memória é a névoa em suas margens.
Caminhamos sobre pontes de luar,
buscando o que já foi perdido.

Somente aqueles que ousam
desvendar os nós do destino
encontrarão a chave.

A engrenagem gira.
O coração bate.
O caminho se revela.

Contempla a Cifra.
Entende o Padrão.
O selo se abre.
A jornada é tua.
        `;

        // --- VARIÁVEIS GLOBAIS ---
        let scene, camera, renderer;
        let sound;
        let crawlGroup, textMesh, textHeight;
        let animationInProgress = false;
        let endThreshold = 0;
        let clock = new THREE.Clock(); 

        // --- CORES ---
        const ARCANE_PURPLE = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--cor-arcana').trim());

        // --- INICIALIZAÇÃO E FUNÇÕES (Sem alterações relevantes nestas) ---
        function init() {
            setupAudio();
            setupScene();
            setupListeners();
            // A assinatura é exibida ao final do loop 'animate'
        }

        function setupAudio() {
            sound = new Howl({
                src: ['./audio-mecanismo.mp3'], 
                loop: true,
                volume: 0.6
            });
        }

        function setupScene() {
            const canvas = document.getElementById('three-canvas');
            scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 1, 10000);
            camera.position.set(0, 150, 400); 
            camera.lookAt(0, 0, 0);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        function setupListeners() {
            document.getElementById('seal-container').addEventListener('click', startExperience, { once: true });
            window.addEventListener('resize', onWindowResize);
        }

        function startExperience() {
            if (animationInProgress) return;
            animationInProgress = true;

            const sealImg = document.getElementById('arcane-seal-img');
            sealImg.classList.add('clicked');
            document.getElementById('seal-container').style.pointerEvents = 'none';

            sound.play();
            createCrawlText();
            animate();
        }

        function createCrawlText() {
            const textCanvas = createTextCanvas(LOREM_IPSUM_ARCANO);
            textHeight = textCanvas.height; 

            const texture = new THREE.CanvasTexture(textCanvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: texture },
                    time: { value: 0.0 },
                    glowColor: { value: ARCANE_PURPLE },
                    // Aumento da força da distorção para ser mais aparente
                    distortionStrength: { value: 0.015 } // Ajuste fino, se necessário
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(textCanvas.width, textHeight);
            textMesh = new THREE.Mesh(geometry, material);

            crawlGroup = new THREE.Group();
            crawlGroup.add(textMesh);
            
            // Inclinação suave
            crawlGroup.rotation.x = -Math.PI / 6; 

            const startY = -textHeight / 2 - 400; 
            crawlGroup.position.y = startY;

            endThreshold = (textHeight * Math.cos(crawlGroup.rotation.x)) * 0.7;

            scene.add(crawlGroup);
        }

        function createTextCanvas(text) {
            const lines = text.split('\n');
            const fontSize = 48; 
            const lineHeight = fontSize * 1.3;
            
            const canvasHeight = lines.length * lineHeight + (fontSize * 2);
            const canvasWidth = 1024; 

            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            const ctx = canvas.getContext('2d');
            
            ctx.font = `${fontSize}px 'Cinzel Decorative'`;
            ctx.fillStyle = '#FFFFFF'; 
            ctx.textAlign = 'center';
            
            ctx.shadowColor = 'transparent'; 
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            let y = fontSize * 2;
            for (const line of lines) {
                ctx.fillText(line, canvasWidth / 2, y);
                y += lineHeight;
            }

            return canvas;
        }

        // --- LOOP DE ANIMAÇÃO ---
        function animate() {
            if (!animationInProgress) return;
            requestAnimationFrame(animate);

            // Atualiza o tempo para o efeito de pulsação e corrupção
            if (textMesh && textMesh.material && textMesh.material.uniforms && textMesh.material.uniforms.time) {
                textMesh.material.uniforms.time.value = clock.getElapsedTime();
            }

            crawlGroup.position.y += 0.3; 

            if (crawlGroup.position.y > endThreshold) {
                finishAnimation();
            }

            renderer.render(scene, camera);
        }

        function finishAnimation() {
            animationInProgress = false;

            if (crawlGroup) {
                scene.remove(crawlGroup);
                // Libera recursos
                if (textMesh.geometry) textMesh.geometry.dispose();
                if (textMesh.material) {
                     if (textMesh.material.map) textMesh.material.map.dispose();
                     textMesh.material.dispose();
                }
            }

            const signature = document.getElementById('signature-container');
            signature.style.display = 'block';
            setTimeout(() => {
                signature.style.opacity = '1';
            }, 100); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
